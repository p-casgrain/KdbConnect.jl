module K_lib

using kdb_c_api_jll
# TODO: Use kdb_c_api_jll as default but use other if env variable given

export IS_EMBEDDED_Q

# Note:
# This file was mostly generated by Clang.jl and edited manually to fix
# parts that were incorrectly parsed. See <root>/src/gen for details.

# fetch kdb C shared library

if "IS_EMBEDDED_Q" in keys(ENV)
    global IS_EMBEDDED_Q = parse(Bool,ENV["IS_EMBEDDED_Q"])
else
    let h = unsafe_load(cglobal(:jl_exe_handle, Ptr{Cvoid}))
        # Is Julia running embedded in q?
        global IS_EMBEDDED_Q = Base.Libc.Libdl.dlsym_e(h, :dl) != C_NULL
    end
end

if IS_EMBEDDED_Q  # Get q C API from the current process
    macro k_sym(fn_name)
        fn_name
    end
else
    macro k_sym(sym)
        return :(($(sym),kdb_c_api_jll.kdb_c_so))
    end
end

# Define C type aliases
const J = Clonglong
const H = Cshort
const I = Cint
const E = Cfloat
const F = Cdouble
const S = Ptr{Cchar}
const C = Cchar
const U = UInt128
const V = Cvoid
const G = Cuchar

# Type Union for convenience
const K_CTypes = Union{J,H,I,E,F,S,C,U,V,G}

# Define Base K type
struct k0
    data::NTuple{24,UInt8}
end
const K = Ptr{k0}

const K_NULL = K(C_NULL)

function Base.getproperty(x::Ptr{k0}, f::Symbol)
    f === :m && return Ptr{Int8}(x + 0)
    f === :a && return Ptr{Int8}(x + 1)
    f === :t && return Ptr{Int8}(x + 2)
    f === :u && return Ptr{C}(x + 3)
    f === :r && return Ptr{I}(x + 4)
    f === :g && return Ptr{G}(x + 8)
    f === :h && return Ptr{H}(x + 8)
    f === :i && return Ptr{I}(x + 8)
    f === :j && return Ptr{J}(x + 8)
    f === :e && return Ptr{E}(x + 8)
    f === :f && return Ptr{F}(x + 8)
    f === :s && return Ptr{S}(x + 8)
    f === :k && return Ptr{K}(x + 8)
    f === :n && return Ptr{J}(x + 8)
    f === :G0 && return Ptr{NTuple{1,G}}(x + 16)
    return getfield(x, f)
end

function Base.getproperty(x::k0, f::Symbol)
    r = Ref{k0}(x)
    ptr = Base.unsafe_convert(Ptr{k0}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{k0}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

# Define Type Constants
TYPE_LETTERS = "kb  ghijefcspmdznuvt"
for (t, x) in enumerate(TYPE_LETTERS)
    isspace(x) || @eval const $(Symbol("K", uppercase(x))) = $(I(t - 1))
end

const UU = I(2)
const XT = I(98)
const XD = I(99)
const EE = I(128)  #   error

# Define head accessors
xt(x::K) = unsafe_load(x.t) # type
xr(x::K) = unsafe_load(x.r) # reference_count
xn(x::K) = unsafe_load(x.n) # size

# define scalar accessors
xg(x::K) = unsafe_load(x.g)
xh(x::K) = unsafe_load(x.h)
xi(x::K) = unsafe_load(x.i)
xj(x::K) = unsafe_load(x.j)
xe(x::K) = unsafe_load(x.e)
xf(x::K) = unsafe_load(x.f)
xs(x::K) = unsafe_string(unsafe_load(x.s))
xk(x::K) = unsafe_load(x.k)
xp(x::K) = unsafe_string(Ptr{C}(x + 16), xn(x)) # string accessor

# xg(x::K_) = unsafe_load(Ptr{G_}(x + 8))
# xs(x::K_) = (s = unsafe_load(Ptr{S_}(x + 8)); s == C_NULL ? "null" : unsafe_string(s))


# vector accessors (no copy)
kG(x::K) = unsafe_wrap(Array, Ptr{G}(x + 16), (xn(x),))
kH(x::K) = unsafe_wrap(Array, Ptr{H}(x + 16), (xn(x),))
kI(x::K) = unsafe_wrap(Array, Ptr{I}(x + 16), (xn(x),))
kJ(x::K) = unsafe_wrap(Array, Ptr{J}(x + 16), (xn(x),))
kE(x::K) = unsafe_wrap(Array, Ptr{E}(x + 16), (xn(x),))
kF(x::K) = unsafe_wrap(Array, Ptr{F}(x + 16), (xn(x),))
kC(x::K) = unsafe_wrap(Array, Ptr{C}(x + 16), (xn(x),))
kS(x::K) = unsafe_wrap(Array, Ptr{S}(x + 16), (xn(x),))
kK(x::K) = unsafe_wrap(Array, Ptr{K}(x + 16), (xn(x),))
#TODO add KU (part of u/GUID type implementation)


kX(::Type{C}, x::K) where {C} = unsafe_wrap(Array, Ptr{C}(x + 16), (xn(x),)) # extra vector loader

# table and dict accessors
# xk(x::K) = unsafe_load(Ptr{K}(x + 8))
xx(x::K) = unsafe_load(x.k, 1)
xy(x::K) = unsafe_load(x.k, 2)

# scalar constructors

# ku(x::U_) =(p = ka(-UU); unsafe_store!(Ptr{U_}(p + 16), x); p)
# ku(x::Integ er) = ku(U_(x))

"Create a keyed table"
knt(arg1, arg2) = ccall(@k_sym(:knt),K,(J,K),arg1,arg2)

"Create a simple list of type and length"
ktn(arg1, arg2) = ccall(@k_sym(:ktn),K,(I,J),arg1,arg2)

"create fixed-length string"
kpn(arg1, arg2) = ccall(@k_sym(:kpn),K,(S,J),arg1,arg2)

# Connection Functions
khpunc(arg1, arg2, arg3, arg4, arg5) = ccall(@k_sym(:khpunc), I, (S, I, S, I, I), arg1, arg2, arg3, arg4, arg5)
khpun(arg1, arg2, arg3, arg4) = ccall(@k_sym(:khpun), I, (S, I, S, I), arg1, arg2, arg3, arg4)
khpu(arg1, arg2, arg3) = ccall(@k_sym(:khpu), I, (S, I, S), arg1, arg2, arg3)
khp(arg1, arg2) = ccall(@k_sym(:khp), I, (S, I), arg1, arg2)
kclose(arg1) = ccall(@k_sym(:kclose), V, (I,), arg1)


# Atom constructors
"Create an atom of type and value"
ktj(arg1, arg2) = ccall(@k_sym(:ktj), K, (I, J), arg1, arg2)

"Create an atom of type"
ka(arg1) = ccall(@k_sym(:ka), K, (I,), arg1)

"Create a boolean"
kb(arg1) = ccall(@k_sym(:kb), K, (I,), arg1)

"Create a byte"
kg(arg1) = ccall(@k_sym(:kg), K, (I,), arg1)

"Create a short"
kh(arg1) = ccall(@k_sym(:kh), K, (I,), arg1)

"Create an int"
ki(arg1) = ccall(@k_sym(:ki), K, (I,), arg1)

"Create a long"
kj(arg1) = ccall(@k_sym(:kj), K, (J,), arg1)

"Create a real"
ke(arg1) = ccall(@k_sym(:ke), K, (F,), arg1)

"Create a float"
kf(arg1) = ccall(@k_sym(:kf), K, (F,), arg1)

"Create a char"
kc(arg1) = ccall(@k_sym(:kc), K, (I,), arg1)

"Create a symbol"
ks(arg1) = ccall(@k_sym(:ks), K, (S,), arg1)

"Create a date"
kd(arg1) = ccall(@k_sym(:kd), K, (I,), arg1)

"Create a datetime (deprecated)"
kz(arg1) = ccall(@k_sym(:kz), K, (F,), arg1)

"Create a time"
kt(arg1) = ccall(@k_sym(:kt), K, (I,), arg1)

"Create a guid"
ku(arg1) = ccall(@k_sym(:ku), K, (U,), arg1)

# Vector Constructors
"Create a char array from string"
kp(arg1) = ccall(@k_sym(:kp), K, (S,), arg1)

knk(args::K...) = knk(length(args), args...)
function knk(n::Integer, args::K...)
    @eval ccall(@k_sym(:knk), K_lib.K, (K_lib.I, K_lib.K...), $n, $(args...))
end

# "Intern n chars from a string"
const _AnyString = Union{String,Symbol,Cstring}
sn(x::_AnyString, n::Integer) = ccall(@k_sym(:sn), S, (S, I), x, n)

"Join an atom to a list"
ja(arg1, arg2) = ccall(@k_sym(:ja), K, (Ptr{K}, Ptr{V}), arg1, arg2)

"Join a symbol to a list"
js(arg1, arg2) = ccall(@k_sym(:js), K, (Ptr{K}, S), arg1, arg2)

"Join a K object to a list"
jk(arg1, arg2) = ccall(@k_sym(:jk), K, (Ptr{K}, K), arg1, arg2)

"Join another K list to a list"
jv(k_, arg2) = ccall(@k_sym(:jv), K, (Ptr{K}, K), k_, arg2)

"Encode a year/month/day as q date"
ymd(arg1, arg2, arg3) = ccall(@k_sym(:ymd), I, (I, I, I), arg1, arg2, arg3)

"Convert q date to yyyymmdd integer"
dj(arg1) = ccall(@k_sym(:dj), I, (I,), arg1)

"decrement reference count"
r0(arg1) = ccall(@k_sym(:r0), V, (K,), arg1)

"increment reference count"
r1(arg1) = ccall(@k_sym(:r1), K, (K,), arg1)

# === Define k function for up to 8 arguments
# """execute string query on handle h, with up to 8 arguments

# """
# k
for i in 1:8
    fn_args = [Symbol("x", j) for j in 1:i]
    typed_args = collect(Expr(:(::), x, :(K)) for x in fn_args)
    @eval k(h::Integer, m::String, $(typed_args...)) = ccall(@k_sym(:k), K, (I, S, K...), h, m, $(fn_args...))
end


m9() = ccall(@k_sym(:m9), V, ())
b9(arg1, arg2) = ccall(@k_sym(:b9), K, (I, K), arg1, arg2)
d9(arg1) = ccall(@k_sym(:d9), K, (K,), arg1)
okx(arg1) = ccall(@k_sym(:okx), I, (K,), arg1)
sd0(arg1) = ccall(@k_sym(:sd0), V, (I,), arg1)
sd0x(d, f) = ccall(@k_sym(:sd0x), V, (I, I), d, f)
sn(arg1, arg2) = ccall(@k_sym(:sn), S, (S, I), arg1, arg2)
ss(arg1) = ccall(@k_sym(:ss), S, (S,), arg1)
ee(arg1) = ccall(@k_sym(:ee), K, (K,), arg1)
sd1(arg1, arg2) = ccall(@k_sym(:sd1), K, (I, Ptr{Cvoid}), arg1, arg2)
xT(arg1) = ccall(@k_sym(:xT), K, (K,), arg1)
xD(arg1, arg2) = ccall(@k_sym(:xD), K, (K, K), arg1, arg2)
orr(arg1) = ccall(@k_sym(:orr), K, (S,), arg1)
dot(arg1, arg2) = ccall(@k_sym(:dot), K, (K, K), arg1, arg2)
sslInfo(x) = ccall(@k_sym(:sslInfo), K, (K,), x)
krr(x) = ccall(@k_sym(:krr), K, (S,), x)

if IS_EMBEDDED_Q
    dl(f, arg1) = ccall(@k_sym(:dl), K, (Ptr{V}, J), f, arg1)
end

# === Define Nulls and Infinities
const nh = typemin(H)
const wh = typemax(H)
const ni = typemin(I)
const wi = typemax(I)
const nj = typemin(J)
const wj = typemax(J)
const ne = E(NaN32)
const we = E(Inf32)
const nf = F(NaN64)
const wf = F(Inf64)


end
